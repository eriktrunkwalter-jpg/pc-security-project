# KernelHardening.ps1
# Maximizes protection against Kernel-mode Rootkits and Bootkits.
# Focuses on Boot Configuration, Driver Policies, and ELAM.

# Self-Elevation
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Start-Process PowerShell -Verb RunAs "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`""
    Exit
}

$ErrorActionPreference = "SilentlyContinue"
Write-Host ">>> MAXIMIZING KERNEL ROOTKIT PROTECTION <<<" -ForegroundColor Cyan

# 1. HARDEN BOOT CONFIGURATION (BCD)
# Prevents loading unsigned drivers or attaching kernel debuggers (common rootkit tactics).
Write-Host "[BCD] Hardening Boot Configuration..." -ForegroundColor Yellow
cmd.exe /c "bcdedit /set {current} testsigning off"
cmd.exe /c "bcdedit /set {current} nointegritychecks off"
cmd.exe /c "bcdedit /set {current} debug off"
cmd.exe /c "bcdedit /set {current} bootstatuspolicy IgnoreAllFailures" # Hides boot info, slight obscurity
Write-Host "[BCD] TestSigning, NoIntegrityChecks, Debugging -> DISABLED" -ForegroundColor Green

# 2. VERIFY SECURE BOOT (Registry Method)
# More reliable than Get-SecureBootUEFI if permissions are tricky.
$sbPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot\State"
$sbState = Get-ItemProperty -Path $sbPath -Name "UEFISecureBootEnabled" -ErrorAction SilentlyContinue
if ($sbState.UEFISecureBootEnabled -eq 1) {
    Write-Host "[SECURE BOOT] Active (Confirmed via Registry)" -ForegroundColor Green
} else {
    Write-Host "[SECURE BOOT] NOT ACTIVE! Check BIOS Settings immediately." -ForegroundColor Red
}

# 3. CONFIGURE ELAM (Early Launch Anti-Malware)
# Instructs kernel to reject 'Bad' or 'Unknown' drivers during boot.
# DriverLoadPolicy: 
# 0 = Load all (Dangerous)
# 1 = Load Good only (Strict)
# 3 = Load Good + Known Bad (Warning)
# 8 = Load Good + Unknown (Balanced)
# We set to 1 (Strict) or 8 (Balanced). Setting to 1 might block obscure drivers.
# Let's set to 8 (Good + Unknown) to be safe but block 'Bad', or 1 for MAX security if user accepts risk.
# User asked for "MAXIMAL". We will set to 1 (Good Only).
$elamPath = "HKLM:\SYSTEM\CurrentControlSet\Control\EarlyLaunch"
if (!(Test-Path $elamPath)) { New-Item -Path $elamPath -Force | Out-Null }
Set-ItemProperty -Path $elamPath -Name "DriverLoadPolicy" -Value 1 -Force
Write-Host "[ELAM] Policy set to 'Load Good Drivers Only' (Strict)" -ForegroundColor Green

# 4. ENFORCE VULNERABLE DRIVER BLOCKLIST (ConfigCI)
$ciPath = "HKLM:\SYSTEM\CurrentControlSet\Control\CI\Config"
if (!(Test-Path $ciPath)) { New-Item -Path $ciPath -Force | Out-Null }
Set-ItemProperty -Path $ciPath -Name "VulnerableDriverBlocklistEnable" -Value 1 -Force
Write-Host "[KERNEL] Microsoft Vulnerable Driver Blocklist -> ENABLED" -ForegroundColor Green

# 5. DISABLE SEHOP (Structured Exception Handler Overwrite Protection) - Wait, this is app level.
# KERNEL LEVEL: Data Execution Prevention (DEP)
# Always On for Kernel is default in 64-bit, but ensure OptIn/OptOut for 32-bit apps.
$dep = Get-WmiObject Win32_OperatingSystem
if ($dep.DataExecutionPrevention_SupportPolicy -eq 2 -or $dep.DataExecutionPrevention_SupportPolicy -eq 3) {
    Write-Host "[DEP] Data Execution Prevention is Active" -ForegroundColor Green
} else {
    # Force AlwaysOn via BCD
    cmd.exe /c "bcdedit /set {current} nx AlwaysOn"
    Write-Host "[DEP] Forced 'AlwaysOn' via BCD" -ForegroundColor Green
}

Write-Host "`n>>> KERNEL PROTECTION MAXIMIZED <<<" -ForegroundColor Cyan
Read-Host "Press Enter to exit..."
